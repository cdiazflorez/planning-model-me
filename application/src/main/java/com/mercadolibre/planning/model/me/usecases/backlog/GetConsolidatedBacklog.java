package com.mercadolibre.planning.model.me.usecases.backlog;

import com.google.common.collect.Sets;
import com.mercadolibre.planning.model.me.entities.monitor.ProcessDetail;
import com.mercadolibre.planning.model.me.entities.monitor.UnitMeasure;
import com.mercadolibre.planning.model.me.entities.monitor.VariablesPhoto;
import com.mercadolibre.planning.model.me.gateways.backlog.dto.Consolidation;
import com.mercadolibre.planning.model.me.gateways.planningmodel.dtos.ProcessName;
import com.mercadolibre.planning.model.me.usecases.backlog.dtos.BacklogStatsByDate;

import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static java.util.Comparator.naturalOrder;

public abstract class GetConsolidatedBacklog {

    private static final long MAX_ALLOWED_MINUTES_SHIFT = 5L;

    private static final long SECOND_IN_HOUR = 3600;

    /**
     * Gets, from the received consolidated backlog trajectory, the date when the latest backlog
     * photo was taken, or the {@code defaultDate} if either the received {@code consolidations}
     * list is empty or the latest photo date is more than five minutes earlier than the
     * {@code defaultDate}. TODO Explain why the second is necessary.
     *
     * @return the date mentioned date.
     */
    protected Instant getDateWhenLatestPhotoWasTaken(
            final List<Consolidation> consolidationTrajectory,
            final Instant defaultDate
    ) {
        return consolidationTrajectory.stream()
                .map(Consolidation::getDate)
                .max(naturalOrder())
                .filter(date -> date.until(defaultDate, ChronoUnit.MINUTES)
                        < MAX_ALLOWED_MINUTES_SHIFT)
                .orElse(defaultDate);
    }

    /** Truncates to hours the dates at which the backlog photos were taken on.*/
    protected List<Consolidation> truncateToHoursTheTakenOnDate(final List<Consolidation> consolidations) {
        return consolidations.stream()
                .map(cellsGroupSum -> cellsGroupSum.isFirstPhotoOfPeriod()
                        ? new Consolidation(
                             cellsGroupSum.getDate().truncatedTo(ChronoUnit.HOURS),
                             cellsGroupSum.getKeys(),
                             cellsGroupSum.getTotal(),
                             cellsGroupSum.isFirstPhotoOfPeriod()
                        )
                        : cellsGroupSum
                )
                .collect(Collectors.toList());
    }

    /**
     * Gives a copy of the received list of consolidations with the empty consolidations slots
     * filled with consolidations generated by the received {@code consolidationSupplier}.
     * There is a consolidation slot at every hour transition contained in the specified time
     * interval, plus one more slot at the end of the interval (dateTo) if it is not an hour
     * boundary.
     *
     * @param consolidations the list of consolidations of the latest backlog photos with the date
     *     truncated to hours except the last <--- FIXME: complex assumptions is a
     *     sign of lack of proper data types. The last photo should be out of the
     *     list in another field.
     * @param dateFrom the hour of the first consolidation slot.
     * @param dateTo the date of the last consolidation slot.
     * @param consolidationSupplier a function from {@link Instant} to {@link Consolidation}.
     * @return a copy of the received list of consolidations with the empty consolidations slots
     *     filled with consolidations generated by the received {@code consolidationSupplier}.
     */
    protected List<Consolidation> fillMissing(
            final List<Consolidation> consolidations,
            final Instant dateFrom,
            final Instant dateTo,
            final Function<Instant, Consolidation> consolidationSupplier
    ) {
        assert dateFrom.equals(dateFrom.truncatedTo(ChronoUnit.HOURS));

        final Set<Instant> currentDates = consolidations.stream()
                .map(Consolidation::getDate)
                .collect(Collectors.toSet());

        final long totalHours = ChronoUnit.HOURS.between(dateFrom, dateTo);

        final Set<Instant> allHours = IntStream.rangeClosed(0, (int) totalHours)
                .mapToObj(hours -> dateFrom.plus(Duration.ofHours(hours)))
                .collect(Collectors.toSet());
        allHours.add(dateTo);

        final List<Consolidation> missing = Sets.difference(allHours, currentDates).stream()
                .map(consolidationSupplier)
                .collect(Collectors.toList());

        missing.addAll(consolidations);

        return missing;
    }

    protected ProcessDetail build(final ProcessName process,
                                  final Instant currentDatetime,
                                  final List<BacklogStatsByDate> backlogs) {

        final List<VariablesPhoto> backlog = backlogs
                .stream()
                .map(stats -> toBacklogByDate(stats, currentDatetime))
                .sorted(Comparator.comparing(VariablesPhoto::getDate))
                .collect(Collectors.toList());

        final UnitMeasure totals = backlog.stream()
                .filter(b -> b.getDate().equals(currentDatetime))
                .findFirst()
                .map(VariablesPhoto::getCurrent)
                .map(measure -> new UnitMeasure(
                        measure.getUnits(),
                        measure.getMinutes() == null ? Integer.valueOf(0) : measure.getMinutes()))
                .orElse(new UnitMeasure(0, 0));

        return new ProcessDetail(process.getName(), totals, backlog);
    }

    protected Map<Instant, UnitMeasure> convertBacklogTrajectoryFromUnitToTime(final List<TotaledBacklogPhoto> totaledBacklogPhotos,
                                                                               final Map<Instant, Integer> throughputByHour) {

        final ThroughputTrajectory throughputTrajectory = new ThroughputTrajectory(new TreeMap<>(throughputByHour));

        return convertTrajectoryFromUnitsToDuration(totaledBacklogPhotos.stream(), throughputTrajectory);
    }

    private VariablesPhoto toBacklogByDate(
            final BacklogStatsByDate description,
            final Instant currentDatetime
    ) {
        final Instant date = currentDatetime.equals(description.getDate())
                ? currentDatetime
                : description.getDate().truncatedTo(ChronoUnit.HOURS);

        return VariablesPhoto.builder()
                .date(date)
                .current(description.getTotal())
                .historical(description.getHistorical())
                .minLimit(description.getMinLimit())
                .maxLimit(description.getMaxLimit())
                .build();
    }

    /** Converts a backlog trajectory from units to the time needed to process them. */
    static Map<Instant, UnitMeasure> convertTrajectoryFromUnitsToDuration(
            final Stream<TotaledBacklogPhoto> backlogTrajectoryInUnits,
            final ThroughputTrajectory throughputTrajectory
    ) {
        return backlogTrajectoryInUnits.collect(Collectors.toMap(
                TotaledBacklogPhoto::getTakenOn,
                item -> new UnitMeasure(
                        item.getQuantity(),
                        (int)ChronoUnit.MINUTES.between(
                                item.getTakenOn(),
                                throughputTrajectory.reversedIntegral(item.getTakenOn(), item.getQuantity())
                        )
                ),
                (a, b) -> {
                    assert a.equals(b);
                    return a;
                }
        ));
    }

    static class ThroughputTrajectory {
        final TreeMap<Instant, Integer> throughputByHour;

        public ThroughputTrajectory(TreeMap<Instant, Integer> throughputByHour) {
            this.throughputByHour = throughputByHour;

            if (throughputByHour.isEmpty()) {
                // An undefined throughput trajectory is interpreted as a constant infinity throughput.
                throughputByHour.put(Instant.ofEpochSecond(0), Integer.MAX_VALUE);
            } else {
                // Extrapolate the left side with the first value
                throughputByHour.put(Instant.ofEpochSecond(0), throughputByHour.firstEntry().getValue());
                // The right side is naturally extrapolated with the last value.
                // To avoid infinite recursion when the last value is zero, a high value point is appended a day after
                // the last.
                throughputByHour.put(
                        throughputByHour.lastKey().plus(1, ChronoUnit.DAYS),
                        Integer.MAX_VALUE
                );
            }
        }

        /**
         * Finds out the {@link Instant} `end` such that the integral of this {@link ThroughputTrajectory} from `start` to
         * `end` equals `targetBacklog`.
         *
         * @param start         the lower limit of the integral.
         * @param targetBacklog the result of the integral of this trajectory from start to end, measured in `unit x hour`.
         */
        public Instant reversedIntegral(final Instant start, final long targetBacklog) {
            if (targetBacklog == 0) {
                return start;
            } else {
                final var throughputAtStart = throughputByHour.floorEntry(start).getValue();
                final Instant nextInflectionPoint = start.plus(1, ChronoUnit.HOURS).truncatedTo(ChronoUnit.HOURS);
                final long integralUntilNextInflectionPoint =
                        (throughputAtStart * ChronoUnit.SECONDS.between(start, nextInflectionPoint)) / SECOND_IN_HOUR;

                if (integralUntilNextInflectionPoint >= targetBacklog) {
                    return start.plusSeconds((targetBacklog * SECOND_IN_HOUR) / throughputAtStart);
                } else {
                    return reversedIntegral(nextInflectionPoint, targetBacklog - integralUntilNextInflectionPoint);
                }
            }
        }
    }
}
